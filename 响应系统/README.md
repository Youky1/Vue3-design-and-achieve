# 响应系统

## 响应系统的原理

通过 Proxy 拦截对属性的读取和赋值：

- 用一个 Set 存储副作用函数，读取时存储
- 赋值时执行所有副作用函数

问题：

- 如何获取副作用函数

## 响应系统的基本实现

解决获取副作用函数的问题：

- 用一个全局变量存储**当前副作用函数**，用一个 effect 函数**执行副作用函数**
- 用一个 WeakMap 存储每个对象的每个 key 对应的依赖列表

将跟踪依赖，以及触发副作用的部分封装为函数

## 分支切换与 cleanup

分支切换：副作用函数中对于变量的依赖有多种可能，当某些变量值改变后，依赖会发生变化。如三元表达式

```javascript
effect(() => {
  console.log(obj.ok ? obj.text : obj.name)
})
```

此时当 `obj.ok` 改变后，对 `obj.text` 的遗留依赖应该清除，否则会导致不必要的更新

清除思路：

- 包装副作用函数，在其 deps 属性中记录所有依赖。
- 每次执行前清除所有依赖

## 嵌套的 effect

> 组件嵌套，其 render 就相当于嵌套的副作用

问题：用一个变量存储当前副作用函数时，当发生嵌套，子函数会覆盖父级副作用函数。
解决：用一个栈存储副作用函数，执行完毕后出栈，栈顶元素始终是当前的副作用函数

## 解决无限递归

发生场景：当一个副作用函数中，同时读取并对属性赋值时，会无限递归（读取时触发 track，赋值时 trigger）

解决：trigger 函数中，判断收集的副作用是否是当前正在执行的函数。如果是则不执行

## 调度执行

概念：当 trigger 动作触发副作用函数重新执行时，有能力决定副作用函数**执行的时机、次数以及方式**

如：

- 将副作用函数放到异步任务执行
- 同一个函数连续多次修改数据只触发一次更新

## 懒执行与计算属性

之前的 effect 函数中，传入的副作用函数会立即执行。
而 computed 中的计算，只有到计算属性被使用的时候，才会执行，称之为**懒执行**
可以通过在 options 中添加一个 lazy 字段，表明是否是懒加载。并返回包装后的副作用函数，在需要的时机执行

computed 函数的关键点：

- 通过 options.lazy 实现懒计算
- 缓存计算结果，在数据变化时更新缓存标志位
- 嵌套问题：在 effect 中使用 computed 值，外层的副作用函数也应加入内部 computed 依赖值的副作用列表中

## watch

要点：

- 自动遍历对象的所有属性，在属性改变时执行回调
- 兼容第一个参数为对象或 getter 函数的格式
- 为回调传入变化前后的两个参数值

options：

- **immediate（立即执行）**：回调函数会立刻执行一次，而不是等到依赖改变才执行
- **flush 执行时机**：回调函数的执行时机
  - pre：在 DOM 更新前
  - post：在 DOM 更新后

Vue 中还有一个类似于 useEffect 的 watch 改良版，watchEffect，它会自动识别回调中依赖的变量，立即执行并在其改变后重新执行。由于 effect 函数就是自动识别变量，所以 watchEffect 的实现很简单:

```javascript
function watchEffect(cb) {
  effect(cb)
}
```

## watch 的过期机制

过期机制要解决的问题：竞态问题。

> 当副作用多次触发时若后续触发的回调优先得到结果，前一次的结果后返回，则该结果已经过期，过期的副作用会覆盖正确结果。

解决办法：为 watch 提供第三个参数，**在过期时会执行的回调 onInvalidate**

实现原理：每次执行副作用函数之前，先判断 onInvalidate 是否执行过（因为此时上一次的副作用已经过期），若是则先执行一遍过期回调函数
