# 对象类型的响应方案

使用 Proxy 代理变量的步骤

1. 确定会对该变量产生依赖的所有情况
2. 根据语言规范确定每种情况下，Proxy 提供的代理方法
3. 实现具体的代理逻辑

## 代理 Object

### 需要代理的场景

1. 读取属性：在 get 中收集依赖，**修改**属性时触发
2. in 运算符：在 has 中收集依赖，**修改**属性时触发
3. for in 循环：在 ownKeys 中收集依赖，在**添加**属性时触发
4. 删除属性，delete 操作

因此，在 set 操作时，要判断此次更新时修改属性还是添加属性。

当类型为 Add 时除了要触发本次修改的 key 对应的副作用列表，还要把和遍历 key 相关的副作用也全部执行。

### 合理的触发响应

1. 在 SET 类型的操作中，只有属性值实际改变了，才需要触发响应
2. 原型链赋值问题

当 A 对象继承了 B 对象时，若读取/赋值 A 不存在的属性，则会沿原型链向 B 查找。此时也就会触发 B 中收集的依赖。

要判断本次更新的真实对象，可以通过 get 的 receiver 对象。**当 set 方法调用父对象的 set 时，target 会变，但是 receiver 始终不变**。

> 如何判断 receiver 是否是 target 的代理对象呢？

在 get 中新加一个逻辑：若 key 为 raw，则返回被代理的原始对象。

### 深响应与浅响应

之前的响应都只对对象的第一层级属性进行了代理，深响应则是对于 get 中返回的每个属性，也进行响应式包装

### readonly

对于只读数据：

- get 中无需收集依赖，因为不会进行修改
- set 修改属性无效
- delete 删除属性无效

同样，readonly 也分浅层和深层

## 代理 Array

### 代理场景

JS 中的数组也是对象，但属于异质对象。对于 set 和 get 的代理对数组仍然生效。但需要对特殊场景做处理

数组的读取场景：

- 通过下标访问数组元素
- 访问 arr.length
- for in 循环
- for of 循环
- 不改变数组本身的原型方法

数组的修改场景：

- 通过下标修改数组元素
- 修改 arr.length
- 改变数组本身的原型方法，push/pop 等栈方法、splice、sort 等

### 索引与 length

对于通过下标修改元素以及修改 length 的场景，数组的特殊在于：

- 当赋值的下标大于当前 length 时，会自动改变 length
- 当修改的 length 小于当前 length 时，会删除元素

## 代理 Set 和 Map

对于 Set 和 Map 的代理与数组原理类似。

Set 和 Map 的读取和增删只能通过特定方法完成，而 set.get 方法可以看做是对属性的读取。

所以代理方法即在读取属性时，判断该属性是否是需要重写的方法，若时则执行预先定义的重写方法。
