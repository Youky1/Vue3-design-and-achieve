# 对象类型的响应方案

使用 Proxy 代理变量的步骤

1. 确定会对该变量产生依赖的所有情况
2. 根据语言规范确定每种情况下，Proxy 提供的代理方法
3. 实现具体的代理逻辑

## 代理 Object

### 需要代理的场景

1. 读取属性：在 get 中收集依赖，**修改**属性时触发
2. in 运算符：在 has 中收集依赖，**修改**属性时触发
3. for in 循环：在 ownKeys 中收集依赖，在**添加**属性时触发
4. 删除属性，delete 操作

因此，在 set 操作时，要判断此次更新时修改属性还是添加属性。

当类型为 Add 时除了要触发本次修改的 key 对应的副作用列表，还要把和遍历 key 相关的副作用也全部执行。

### 合理的触发响应

1. 在 SET 类型的操作中，只有属性值实际改变了，才需要触发响应
2. 原型链赋值问题

当 A 对象继承了 B 对象时，若读取/赋值 A 不存在的属性，则会沿原型链向 B 查找。此时也就会触发 B 中收集的依赖。

要判断本次更新的真实对象，可以通过 get 的 receiver 对象。**当 set 方法调用父对象的 set 时，target 会变，但是 receiver 始终不变**。

> 如何判断 receiver 是否是 target 的代理对象呢？

在 get 中新加一个逻辑：若 key 为 raw，则返回被代理的原始对象。

### 深响应与浅响应

之前的响应都只对对象的第一层级属性进行了代理，深响应则是对于 get 中返回的每个属性，也进行响应式包装

### readonly

对于只读数据：

- get 中无需收集依赖，因为不会进行修改
- set 修改属性无效
- delete 删除属性无效

同样，readonly 也分浅层和深层

## 代理 Array

## 代理 Set 和 Map
